* Full Permutation 全排列

把 1~n 这 n 个整数按照某个顺序摆放的结果称为这 n 个整数的一个排列，而全排列指这 n 个数能形成的所有排列。

例如对 {1, 2, 3} 这三个整数来说，以下就是它的全排列。

#+BEGIN_SRC text
1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
#+END_SRC

目标：用递归实现 “输出 1~n 这 n 个整数的全排列”

** 分析

高中排列组合，每个排列都有 n 位，第一位 有 n 个数可以填，第二位 有除了前面的数，余下 n-1 个数可以填，第三位 有除了前面的数，余下 n-2 个数，以此类推，第 n 位只有一个数可以选择，于是我们算出共有 n! 种排列。

现在要输出每一个排列情况，上面的逻辑就是一个很好的分治思想。

问题A  “输出 1~n 这 n 个整数的全排列” 可分解为子问题序列A1~An

A = {"输出 1 开头的全排列"，"输出 2 开头的全排列", ...,"输出 n 开头的全排列"}

而每个子问题 Ai 又可以分解为 Ai1~Ain

Ai ={"输出 i1 开头的全排列"，"输出 i2 开头的全排列", ...,"输出 in 开头的全排列"}

直到无法分解，这时候合并每一个问题的解，就得到A的解。

- 假设已经填好的是 permu[1]~permu[i]，在填第 i+1 位时需要将前面的数从选择列表中除去
  解决方法：使用一个散列数组 has 记录

直观的描述，就好像行李箱密码锁密码忘记，人为从 000~999 暴力破解。（只是每位只有三个数可以选，且每位数字都必须不一样）

#+BEGIN_SRC text
1 2 3 4 5 6 ... n-1 n
----------- ... -----
1 2 3 4 5 6 ... n-1 n
1 2 4 3 5 6 ... n-1 n
.
.
.
2 1 3 4 5 6 ... n-1 n
2 1 4 3 5 6 ... n-1 n
.
.
.
#+END_SRC

- 递归边界：问题分解到第 n+1 层 （此时，序列的每一位已经确认）
- 递归式：Ai->{Aik}

#+BEGIN_SRC c++
  #include <cstdio>
  const int maxn = 11;
  int n, permu[maxn], has[maxn] = {false}, show = 0;
  void fullpermu(int pos) { //pos 为位数, n 为数组元素个数
      if(pos==n+1){ //递归边界
          for(int i=1; i<=n; i++)
              printf("%d", permu[i]);
          printf(" ");
          show++;
          if(!(show%6))
              printf("\n");
          return;
      }
      for(int x=1; x<=n; x++){ //枚举 1~n 根据 has 填入 permu
          if(!has[x]){ //如果 x 不是开头序列里的数
              permu[pos] = x; // pos 位填 x
              has[x] = true; //加入开头序列
              fullpermu(pos+1); //子问题 Ax
              has[x] = false; //子问题 Ax 解决
          }
      }
  }
  int main() {
      n = 4; //输出 1~3 的全排列
      fullpermu(1); //分解问题
      return 0;
  }
  /*-----console-----
    1234 1243 1324 1342 1423 1432
    2134 2143 2314 2341 2413 2431
    3124 3142 3214 3241 3412 3421
    4123 4132 4213 4231 4312 4321
   ,*///------------
#+END_SRC
